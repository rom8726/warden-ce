/* tslint:disable */
/* eslint-disable */
/**
 * Backend for Sentry-Compatible API Project
 * OpenAPI specification for a backend server for a compatible with the Sentry SDK project.
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddProjectRequest
 */
export interface AddProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof AddProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddProjectRequest
     */
    'description': string;
    /**
     * CPU architecture of the device
     * @type {number}
     * @memberof AddProjectRequest
     */
    'team_id'?: number | null;
}
/**
 * 
 * @export
 * @interface AddTeamMemberRequest
 */
export interface AddTeamMemberRequest {
    /**
     * 
     * @type {number}
     * @memberof AddTeamMemberRequest
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof AddTeamMemberRequest
     */
    'role': AddTeamMemberRequestRoleEnum;
}

export const AddTeamMemberRequestRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member'
} as const;

export type AddTeamMemberRequestRoleEnum = typeof AddTeamMemberRequestRoleEnum[keyof typeof AddTeamMemberRequestRoleEnum];

/**
 * 
 * @export
 * @interface ChangeIssueStatusRequest
 */
export interface ChangeIssueStatusRequest {
    /**
     * 
     * @type {IssueStatus}
     * @memberof ChangeIssueStatusRequest
     */
    'status': IssueStatus;
}


/**
 * 
 * @export
 * @interface ChangeTeamMemberRoleRequest
 */
export interface ChangeTeamMemberRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamMemberRoleRequest
     */
    'role': ChangeTeamMemberRoleRequestRoleEnum;
}

export const ChangeTeamMemberRoleRequestRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member'
} as const;

export type ChangeTeamMemberRoleRequestRoleEnum = typeof ChangeTeamMemberRoleRequestRoleEnum[keyof typeof ChangeTeamMemberRoleRequestRoleEnum];

/**
 * 
 * @export
 * @interface ChangeUserPasswordRequest
 */
export interface ChangeUserPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeUserPasswordRequest
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeUserPasswordRequest
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface CompareProjectReleasesAnalyticsRequest
 */
export interface CompareProjectReleasesAnalyticsRequest {
    /**
     * 
     * @type {string}
     * @memberof CompareProjectReleasesAnalyticsRequest
     */
    'base_version': string;
    /**
     * 
     * @type {string}
     * @memberof CompareProjectReleasesAnalyticsRequest
     */
    'target_version': string;
}
/**
 * 
 * @export
 * @interface ComponentVersion
 */
export interface ComponentVersion {
    /**
     * Name of the component
     * @type {string}
     * @memberof ComponentVersion
     */
    'name': string;
    /**
     * Version of the component
     * @type {string}
     * @memberof ComponentVersion
     */
    'version': string;
    /**
     * Build time of the component
     * @type {string}
     * @memberof ComponentVersion
     */
    'build_time': string;
    /**
     * Status of the component\'s tech server
     * @type {string}
     * @memberof ComponentVersion
     */
    'status': ComponentVersionStatusEnum;
}

export const ComponentVersionStatusEnum = {
    Available: 'available',
    Unavailable: 'unavailable'
} as const;

export type ComponentVersionStatusEnum = typeof ComponentVersionStatusEnum[keyof typeof ComponentVersionStatusEnum];

/**
 * 
 * @export
 * @interface CreateNotificationRuleRequest
 */
export interface CreateNotificationRuleRequest {
    /**
     * Level of event to trigger notification (error, warning, info, etc.)
     * @type {string}
     * @memberof CreateNotificationRuleRequest
     */
    'event_level'?: string | null;
    /**
     * Specific error fingerprint to trigger notification
     * @type {string}
     * @memberof CreateNotificationRuleRequest
     */
    'fingerprint'?: string | null;
    /**
     * Trigger only for new errors
     * @type {boolean}
     * @memberof CreateNotificationRuleRequest
     */
    'is_new_error'?: boolean | null;
    /**
     * Trigger only for regressions (resolved -> unresolved)
     * @type {boolean}
     * @memberof CreateNotificationRuleRequest
     */
    'is_regression'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateNotificationSettingRequest
 */
export interface CreateNotificationSettingRequest {
    /**
     * 
     * @type {NotificationChannelType}
     * @memberof CreateNotificationSettingRequest
     */
    'type': NotificationChannelType;
    /**
     * Configuration for the notification channel (JSONB in database)
     * @type {string}
     * @memberof CreateNotificationSettingRequest
     */
    'config': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateNotificationSettingRequest
     */
    'enabled'?: boolean;
}


/**
 * 
 * @export
 * @interface CreateTeamRequest
 */
export interface CreateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateTeamResponse
 */
export interface CreateTeamResponse {
    /**
     * 
     * @type {Team}
     * @memberof CreateTeamResponse
     */
    'team': Team;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'is_superuser'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * 
     * @type {User}
     * @memberof CreateUserResponse
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface Error2FARequired
 */
export interface Error2FARequired {
    /**
     * 
     * @type {Error2FARequiredError}
     * @memberof Error2FARequired
     */
    'error': Error2FARequiredError;
}
/**
 * 
 * @export
 * @interface Error2FARequiredError
 */
export interface Error2FARequiredError {
    /**
     * 
     * @type {string}
     * @memberof Error2FARequiredError
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Error2FARequiredError
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof Error2FARequiredError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ErrorBadRequest
 */
export interface ErrorBadRequest {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorBadRequest
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorError
 */
export interface ErrorError {
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ErrorInternalServerError
 */
export interface ErrorInternalServerError {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorInternalServerError
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorInvalidCredentials
 */
export interface ErrorInvalidCredentials {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorInvalidCredentials
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorInvalidToken
 */
export interface ErrorInvalidToken {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorInvalidToken
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorNotFound
 */
export interface ErrorNotFound {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorNotFound
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorPermissionDenied
 */
export interface ErrorPermissionDenied {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorPermissionDenied
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorTooManyRequests
 */
export interface ErrorTooManyRequests {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorTooManyRequests
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ErrorUnauthorized
 */
export interface ErrorUnauthorized {
    /**
     * 
     * @type {ErrorError}
     * @memberof ErrorUnauthorized
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface Issue
 */
export interface Issue {
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'project_id': number;
    /**
     * 
     * @type {IssueSource}
     * @memberof Issue
     */
    'source': IssueSource;
    /**
     * 
     * @type {IssueStatus}
     * @memberof Issue
     */
    'status': IssueStatus;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'message': string;
    /**
     * 
     * @type {IssueLevel}
     * @memberof Issue
     */
    'level': IssueLevel;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'platform': string;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'first_seen': string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'last_seen': string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'resolved_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'resolved_by'?: string;
}


/**
 * Full representation of domain.Event
 * @export
 * @interface IssueEvent
 */
export interface IssueEvent {
    /**
     * Unique identifier of the event (domain.Event.ID)
     * @type {string}
     * @memberof IssueEvent
     */
    'event_id': string;
    /**
     * Time when the event occurred
     * @type {string}
     * @memberof IssueEvent
     */
    'timestamp': string;
    /**
     * Hash used for grouping events
     * @type {string}
     * @memberof IssueEvent
     */
    'group_hash'?: string;
    /**
     * Identifier of the project that owns the event
     * @type {number}
     * @memberof IssueEvent
     */
    'project_id': number;
    /**
     * 
     * @type {IssueLevel}
     * @memberof IssueEvent
     */
    'level': IssueLevel;
    /**
     * 
     * @type {IssueSource}
     * @memberof IssueEvent
     */
    'source': IssueSource;
    /**
     * Platform that sent the event
     * @type {string}
     * @memberof IssueEvent
     */
    'platform': string;
    /**
     * Short textual description of the event
     * @type {string}
     * @memberof IssueEvent
     */
    'message': string;
    /**
     * Raw JSON payload as received from the client
     * @type {{ [key: string]: any; }}
     * @memberof IssueEvent
     */
    'payload'?: { [key: string]: any; };
    /**
     * Key-value tags attached to the event
     * @type {{ [key: string]: string; }}
     * @memberof IssueEvent
     */
    'tags'?: { [key: string]: string; };
    /**
     * Hostname of the server where the event happened
     * @type {string}
     * @memberof IssueEvent
     */
    'server_name'?: string;
    /**
     * Runtime environment (production, staging, etc.)
     * @type {string}
     * @memberof IssueEvent
     */
    'environment'?: string;
    /**
     * Application release version
     * @type {string}
     * @memberof IssueEvent
     */
    'release'?: string;
    /**
     * Exception class/type
     * @type {string}
     * @memberof IssueEvent
     */
    'exception_type'?: string | null;
    /**
     * Exception message
     * @type {string}
     * @memberof IssueEvent
     */
    'exception_value'?: string | null;
    /**
     * Exception stacktrace
     * @type {string}
     * @memberof IssueEvent
     */
    'exception_stacktrace'?: string | null;
    /**
     * Full request URL
     * @type {string}
     * @memberof IssueEvent
     */
    'request_url'?: string | null;
    /**
     * HTTP method
     * @type {string}
     * @memberof IssueEvent
     */
    'request_method'?: string | null;
    /**
     * Raw query string
     * @type {string}
     * @memberof IssueEvent
     */
    'request_query'?: string | null;
    /**
     * HTTP headers
     * @type {{ [key: string]: string; }}
     * @memberof IssueEvent
     */
    'request_headers'?: { [key: string]: string; } | null;
    /**
     * Request body (as sent)
     * @type {string}
     * @memberof IssueEvent
     */
    'request_data'?: string | null;
    /**
     * Cookies string
     * @type {string}
     * @memberof IssueEvent
     */
    'request_cookies'?: string | null;
    /**
     * Client IP address
     * @type {string}
     * @memberof IssueEvent
     */
    'request_ip'?: string | null;
    /**
     * User-Agent header
     * @type {string}
     * @memberof IssueEvent
     */
    'user_agent'?: string | null;
    /**
     * User identifier
     * @type {string}
     * @memberof IssueEvent
     */
    'user_id'?: string | null;
    /**
     * User email address
     * @type {string}
     * @memberof IssueEvent
     */
    'user_email'?: string | null;
    /**
     * Runtime name (e.g., node, python)
     * @type {string}
     * @memberof IssueEvent
     */
    'runtime_name'?: string | null;
    /**
     * Runtime version
     * @type {string}
     * @memberof IssueEvent
     */
    'runtime_version'?: string | null;
    /**
     * Operating system name
     * @type {string}
     * @memberof IssueEvent
     */
    'os_name'?: string | null;
    /**
     * Operating system version
     * @type {string}
     * @memberof IssueEvent
     */
    'os_version'?: string | null;
    /**
     * Browser name
     * @type {string}
     * @memberof IssueEvent
     */
    'browser_name'?: string | null;
    /**
     * Browser version
     * @type {string}
     * @memberof IssueEvent
     */
    'browser_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IssueEvent
     */
    'device_arch'?: string | null;
}


/**
 * Issue level
 * @export
 * @enum {string}
 */

export const IssueLevel = {
    Fatal: 'fatal',
    Exception: 'exception',
    Error: 'error',
    Warning: 'warning',
    Info: 'info',
    Debug: 'debug'
} as const;

export type IssueLevel = typeof IssueLevel[keyof typeof IssueLevel];


/**
 * 
 * @export
 * @interface IssueResponse
 */
export interface IssueResponse {
    /**
     * 
     * @type {IssueSource}
     * @memberof IssueResponse
     */
    'source': IssueSource;
    /**
     * 
     * @type {Issue}
     * @memberof IssueResponse
     */
    'issue': Issue;
    /**
     * 
     * @type {Array<IssueEvent>}
     * @memberof IssueResponse
     */
    'events': Array<IssueEvent>;
}


/**
 * Column to sort issues by
 * @export
 * @enum {string}
 */

export const IssueSortColumn = {
    TotalEvents: 'total_events',
    FirstSeen: 'first_seen',
    LastSeen: 'last_seen'
} as const;

export type IssueSortColumn = typeof IssueSortColumn[keyof typeof IssueSortColumn];


/**
 * Identifies where the issue comes from.
 * @export
 * @enum {string}
 */

export const IssueSource = {
    Event: 'event',
    Exception: 'exception'
} as const;

export type IssueSource = typeof IssueSource[keyof typeof IssueSource];


/**
 * Resolved or not.
 * @export
 * @enum {string}
 */

export const IssueStatus = {
    Resolved: 'resolved',
    Unresolved: 'unresolved',
    Ignored: 'ignored'
} as const;

export type IssueStatus = typeof IssueStatus[keyof typeof IssueStatus];


/**
 * 
 * @export
 * @interface IssueSummary
 */
export interface IssueSummary {
    /**
     * 
     * @type {number}
     * @memberof IssueSummary
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof IssueSummary
     */
    'project_id': number;
    /**
     * 
     * @type {string}
     * @memberof IssueSummary
     */
    'title': string;
    /**
     * 
     * @type {IssueLevel}
     * @memberof IssueSummary
     */
    'level': IssueLevel;
    /**
     * 
     * @type {number}
     * @memberof IssueSummary
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof IssueSummary
     */
    'last_seen': string;
}


/**
 * 
 * @export
 * @interface ListIssueSummariesResponse
 */
export interface ListIssueSummariesResponse {
    /**
     * 
     * @type {Array<IssueSummary>}
     * @memberof ListIssueSummariesResponse
     */
    'issues': Array<IssueSummary>;
}
/**
 * 
 * @export
 * @interface ListIssuesResponse
 */
export interface ListIssuesResponse {
    /**
     * 
     * @type {Array<Issue>}
     * @memberof ListIssuesResponse
     */
    'issues': Array<Issue>;
    /**
     * 
     * @type {number}
     * @memberof ListIssuesResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ListIssuesResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListIssuesResponse
     */
    'per_page': number;
}
/**
 * 
 * @export
 * @interface ListNotificationRulesResponse
 */
export interface ListNotificationRulesResponse {
    /**
     * 
     * @type {Array<NotificationRule>}
     * @memberof ListNotificationRulesResponse
     */
    'notification_rules': Array<NotificationRule>;
}
/**
 * 
 * @export
 * @interface ListNotificationSettingsResponse
 */
export interface ListNotificationSettingsResponse {
    /**
     * 
     * @type {Array<NotificationSetting>}
     * @memberof ListNotificationSettingsResponse
     */
    'notification_settings': Array<NotificationSetting>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    'is_tmp_password': boolean;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {ErrorError}
     * @memberof ModelError
     */
    'error': ErrorError;
}
/**
 * Type of notification channel (email, mattermost, slack, etc.)
 * @export
 * @enum {string}
 */

export const NotificationChannelType = {
    Email: 'email',
    Telegram: 'telegram',
    Slack: 'slack',
    Mattermost: 'mattermost',
    Webhook: 'webhook',
    Pachca: 'pachca'
} as const;

export type NotificationChannelType = typeof NotificationChannelType[keyof typeof NotificationChannelType];


/**
 * 
 * @export
 * @interface NotificationRule
 */
export interface NotificationRule {
    /**
     * 
     * @type {number}
     * @memberof NotificationRule
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationRule
     */
    'notification_setting_id': number;
    /**
     * Level of event to trigger notification (error, warning, info, etc.)
     * @type {string}
     * @memberof NotificationRule
     */
    'event_level'?: string | null;
    /**
     * Specific error fingerprint to trigger notification
     * @type {string}
     * @memberof NotificationRule
     */
    'fingerprint'?: string | null;
    /**
     * Trigger only for new errors
     * @type {boolean}
     * @memberof NotificationRule
     */
    'is_new_error'?: boolean | null;
    /**
     * Trigger only for regressions (resolved -> unresolved)
     * @type {boolean}
     * @memberof NotificationRule
     */
    'is_regression'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationRule
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface NotificationSetting
 */
export interface NotificationSetting {
    /**
     * 
     * @type {number}
     * @memberof NotificationSetting
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationSetting
     */
    'project_id': number;
    /**
     * Type of notification channel (email, mattermost, slack, etc.)
     * @type {string}
     * @memberof NotificationSetting
     */
    'type': string;
    /**
     * Configuration for the notification channel (JSONB in database)
     * @type {string}
     * @memberof NotificationSetting
     */
    'config': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationSetting
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSetting
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Period
 */
export interface Period {
    /**
     * 
     * @type {string}
     * @memberof Period
     */
    'interval': string;
    /**
     * 
     * @type {string}
     * @memberof Period
     */
    'granularity': string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'team_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'team_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'public_key': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface ProjectResponse
 */
export interface ProjectResponse {
    /**
     * 
     * @type {Project}
     * @memberof ProjectResponse
     */
    'project': Project;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponse
 */
export interface ProjectStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponse
     */
    'total_issues': number;
    /**
     * 
     * @type {ProjectStatsResponseIssuesByLevel}
     * @memberof ProjectStatsResponse
     */
    'issues_by_level': ProjectStatsResponseIssuesByLevel;
    /**
     * 
     * @type {Array<IssueSummary>}
     * @memberof ProjectStatsResponse
     */
    'most_frequent_issues': Array<IssueSummary>;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponseIssuesByLevel
 */
export interface ProjectStatsResponseIssuesByLevel {
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponseIssuesByLevel
     */
    'fatal': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponseIssuesByLevel
     */
    'exception': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponseIssuesByLevel
     */
    'error': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponseIssuesByLevel
     */
    'warning': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponseIssuesByLevel
     */
    'info': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponseIssuesByLevel
     */
    'debug': number;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenResponse
     */
    'expires_in': number;
}
/**
 * 
 * @export
 * @interface ReleaseAnalyticsDetails
 */
export interface ReleaseAnalyticsDetails {
    /**
     * 
     * @type {string}
     * @memberof ReleaseAnalyticsDetails
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseAnalyticsDetails
     */
    'created_at': string;
    /**
     * 
     * @type {ReleaseAnalyticsSummary}
     * @memberof ReleaseAnalyticsDetails
     */
    'stats': ReleaseAnalyticsSummary;
    /**
     * 
     * @type {Array<IssueSummary>}
     * @memberof ReleaseAnalyticsDetails
     */
    'top_issues': Array<IssueSummary>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseAnalyticsDetails
     */
    'severity_distribution': { [key: string]: number; };
    /**
     * 
     * @type {ReleaseAnalyticsDetailsFixTime}
     * @memberof ReleaseAnalyticsDetails
     */
    'fix_time': ReleaseAnalyticsDetailsFixTime;
    /**
     * 
     * @type {ReleaseAnalyticsDetailsSegments}
     * @memberof ReleaseAnalyticsDetails
     */
    'segments': ReleaseAnalyticsDetailsSegments;
}
/**
 * 
 * @export
 * @interface ReleaseAnalyticsDetailsFixTime
 */
export interface ReleaseAnalyticsDetailsFixTime {
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsDetailsFixTime
     */
    'avg'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsDetailsFixTime
     */
    'median'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsDetailsFixTime
     */
    'p95'?: number;
}
/**
 * 
 * @export
 * @interface ReleaseAnalyticsDetailsSegments
 */
export interface ReleaseAnalyticsDetailsSegments {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseAnalyticsDetailsSegments
     */
    'platform'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseAnalyticsDetailsSegments
     */
    'browser_name'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseAnalyticsDetailsSegments
     */
    'os_name'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseAnalyticsDetailsSegments
     */
    'device_arch'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseAnalyticsDetailsSegments
     */
    'runtime_name'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface ReleaseAnalyticsSummary
 */
export interface ReleaseAnalyticsSummary {
    /**
     * 
     * @type {string}
     * @memberof ReleaseAnalyticsSummary
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseAnalyticsSummary
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsSummary
     */
    'known_issues_total': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsSummary
     */
    'new_issues_total': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsSummary
     */
    'regressions_total': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsSummary
     */
    'resolved_in_version_total': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseAnalyticsSummary
     */
    'users_affected': number;
}
/**
 * 
 * @export
 * @interface ReleaseComparison
 */
export interface ReleaseComparison {
    /**
     * 
     * @type {ReleaseAnalyticsSummary}
     * @memberof ReleaseComparison
     */
    'base': ReleaseAnalyticsSummary;
    /**
     * 
     * @type {ReleaseAnalyticsSummary}
     * @memberof ReleaseComparison
     */
    'target': ReleaseAnalyticsSummary;
    /**
     * 
     * @type {ReleaseComparisonDelta}
     * @memberof ReleaseComparison
     */
    'delta': ReleaseComparisonDelta;
}
/**
 * 
 * @export
 * @interface ReleaseComparisonDelta
 */
export interface ReleaseComparisonDelta {
    /**
     * 
     * @type {number}
     * @memberof ReleaseComparisonDelta
     */
    'known_issues_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseComparisonDelta
     */
    'new_issues_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseComparisonDelta
     */
    'regressions_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseComparisonDelta
     */
    'resolved_in_version_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseComparisonDelta
     */
    'users_affected'?: number;
}
/**
 * 
 * @export
 * @interface ReleaseSegmentsResponse
 */
export interface ReleaseSegmentsResponse {
    /**
     * 
     * @type {string}
     * @memberof ReleaseSegmentsResponse
     */
    'segment': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ReleaseSegmentsResponse
     */
    'values': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface SetSuperuserStatusRequest
 */
export interface SetSuperuserStatusRequest {
    /**
     * 
     * @type {boolean}
     * @memberof SetSuperuserStatusRequest
     */
    'is_superuser': boolean;
}
/**
 * 
 * @export
 * @interface SetUserActiveStatusRequest
 */
export interface SetUserActiveStatusRequest {
    /**
     * 
     * @type {boolean}
     * @memberof SetUserActiveStatusRequest
     */
    'is_active': boolean;
}
/**
 * Sort order (ascending or descending)
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof SuccessResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'created_at': string;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof Team
     */
    'members': Array<TeamMember>;
}
/**
 * 
 * @export
 * @interface TeamExistsResponse
 */
export interface TeamExistsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TeamExistsResponse
     */
    'exists': boolean;
}
/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {number}
     * @memberof TeamMember
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'role': TeamMemberRoleEnum;
}

export const TeamMemberRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member'
} as const;

export type TeamMemberRoleEnum = typeof TeamMemberRoleEnum[keyof typeof TeamMemberRoleEnum];

/**
 * 
 * @export
 * @interface TeamResponse
 */
export interface TeamResponse {
    /**
     * 
     * @type {Team}
     * @memberof TeamResponse
     */
    'team': Team;
}
/**
 * 
 * @export
 * @interface TimeseriesData
 */
export interface TimeseriesData {
    /**
     * 
     * @type {Period}
     * @memberof TimeseriesData
     */
    'period': Period;
    /**
     * 
     * @type {string}
     * @memberof TimeseriesData
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TimeseriesData
     */
    'occurrences': Array<number>;
}
/**
 * 
 * @export
 * @interface TwoFAConfirmRequest
 */
export interface TwoFAConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof TwoFAConfirmRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface TwoFADisableRequest
 */
export interface TwoFADisableRequest {
    /**
     * 
     * @type {string}
     * @memberof TwoFADisableRequest
     */
    'email_code': string;
}
/**
 * 
 * @export
 * @interface TwoFAResetRequest
 */
export interface TwoFAResetRequest {
    /**
     * 
     * @type {string}
     * @memberof TwoFAResetRequest
     */
    'email_code': string;
}
/**
 * 
 * @export
 * @interface TwoFASetupResponse
 */
export interface TwoFASetupResponse {
    /**
     * 
     * @type {string}
     * @memberof TwoFASetupResponse
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof TwoFASetupResponse
     */
    'qr_url': string;
    /**
     * Base64 PNG QR image
     * @type {string}
     * @memberof TwoFASetupResponse
     */
    'qr_image': string;
}
/**
 * 
 * @export
 * @interface TwoFAVerifyRequest
 */
export interface TwoFAVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof TwoFAVerifyRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof TwoFAVerifyRequest
     */
    'session_id': string;
}
/**
 * 
 * @export
 * @interface TwoFAVerifyResponse
 */
export interface TwoFAVerifyResponse {
    /**
     * 
     * @type {string}
     * @memberof TwoFAVerifyResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TwoFAVerifyResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof TwoFAVerifyResponse
     */
    'expires_in': number;
}
/**
 * 
 * @export
 * @interface UnreadCountResponse
 */
export interface UnreadCountResponse {
    /**
     * 
     * @type {number}
     * @memberof UnreadCountResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface UpdateNotificationRuleRequest
 */
export interface UpdateNotificationRuleRequest {
    /**
     * Level of event to trigger notification (error, warning, info, etc.)
     * @type {string}
     * @memberof UpdateNotificationRuleRequest
     */
    'event_level'?: string | null;
    /**
     * Specific error fingerprint to trigger notification
     * @type {string}
     * @memberof UpdateNotificationRuleRequest
     */
    'fingerprint'?: string | null;
    /**
     * Trigger only for new errors
     * @type {boolean}
     * @memberof UpdateNotificationRuleRequest
     */
    'is_new_error'?: boolean | null;
    /**
     * Trigger only for regressions (resolved -> unresolved)
     * @type {boolean}
     * @memberof UpdateNotificationRuleRequest
     */
    'is_regression'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateNotificationSettingRequest
 */
export interface UpdateNotificationSettingRequest {
    /**
     * Type of notification channel (email, mattermost, slack, etc.)
     * @type {string}
     * @memberof UpdateNotificationSettingRequest
     */
    'type'?: string;
    /**
     * Configuration for the notification channel (JSONB in database)
     * @type {string}
     * @memberof UpdateNotificationSettingRequest
     */
    'config'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationSettingRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_superuser': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_tmp_password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'two_fa_enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_login'?: string;
    /**
     * 
     * @type {Array<UserTeam>}
     * @memberof User
     */
    'teams'?: Array<UserTeam>;
}
/**
 * 
 * @export
 * @interface UserNotification
 */
export interface UserNotification {
    /**
     * 
     * @type {number}
     * @memberof UserNotification
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UserNotification
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof UserNotification
     */
    'type': UserNotificationTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserNotification
     */
    'content': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof UserNotification
     */
    'is_read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserNotification
     */
    'email_sent': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserNotification
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserNotification
     */
    'updated_at': string;
}

export const UserNotificationTypeEnum = {
    TeamAdded: 'team_added',
    TeamRemoved: 'team_removed',
    RoleChanged: 'role_changed',
    IssueRegression: 'issue_regression'
} as const;

export type UserNotificationTypeEnum = typeof UserNotificationTypeEnum[keyof typeof UserNotificationTypeEnum];

/**
 * 
 * @export
 * @interface UserNotificationsResponse
 */
export interface UserNotificationsResponse {
    /**
     * 
     * @type {Array<UserNotification>}
     * @memberof UserNotificationsResponse
     */
    'notifications': Array<UserNotification>;
    /**
     * 
     * @type {number}
     * @memberof UserNotificationsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface UserTeam
 */
export interface UserTeam {
    /**
     * 
     * @type {number}
     * @memberof UserTeam
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserTeam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserTeam
     */
    'role': UserTeamRoleEnum;
    /**
     * Whether user can leave this team
     * @type {boolean}
     * @memberof UserTeam
     */
    'can_leave'?: boolean;
}

export const UserTeamRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member'
} as const;

export type UserTeamRoleEnum = typeof UserTeamRoleEnum[keyof typeof UserTeamRoleEnum];

/**
 * 
 * @export
 * @interface UserWithTeamsInfo
 */
export interface UserWithTeamsInfo {
    /**
     * 
     * @type {User}
     * @memberof UserWithTeamsInfo
     */
    'user': User;
    /**
     * 
     * @type {Array<UserTeam>}
     * @memberof UserWithTeamsInfo
     */
    'teams': Array<UserTeam>;
}
/**
 * 
 * @export
 * @interface VersionsResponse
 */
export interface VersionsResponse {
    /**
     * List of all system components with their versions
     * @type {Array<ComponentVersion>}
     * @memberof VersionsResponse
     */
    'components': Array<ComponentVersion>;
    /**
     * Timestamp when the versions were collected
     * @type {string}
     * @memberof VersionsResponse
     */
    'collected_at': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject: async (addProjectRequest: AddProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addProjectRequest' is not null or undefined
            assertParamExists('addProject', 'addProjectRequest', addProjectRequest)
            const localVarPath = `/api/v1/projects/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a user to a team
         * @param {number} teamId 
         * @param {AddTeamMemberRequest} addTeamMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamMember: async (teamId: number, addTeamMemberRequest: AddTeamMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addTeamMember', 'teamId', teamId)
            // verify required parameter 'addTeamMemberRequest' is not null or undefined
            assertParamExists('addTeamMember', 'addTeamMemberRequest', addTeamMemberRequest)
            const localVarPath = `/api/v1/teams/{team_id}/members`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('archiveProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change issue status
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {ChangeIssueStatusRequest} changeIssueStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeIssueStatus: async (projectId: number, issueId: number, changeIssueStatusRequest: ChangeIssueStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('changeIssueStatus', 'projectId', projectId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('changeIssueStatus', 'issueId', issueId)
            // verify required parameter 'changeIssueStatusRequest' is not null or undefined
            assertParamExists('changeIssueStatus', 'changeIssueStatusRequest', changeIssueStatusRequest)
            const localVarPath = `/api/v1/projects/{project_id}/issues/{issue_id}/change-status`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeIssueStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change team member role
         * @param {number} teamId 
         * @param {number} userId 
         * @param {ChangeTeamMemberRoleRequest} changeTeamMemberRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamMemberRole: async (teamId: number, userId: number, changeTeamMemberRoleRequest: ChangeTeamMemberRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('changeTeamMemberRole', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeTeamMemberRole', 'userId', userId)
            // verify required parameter 'changeTeamMemberRoleRequest' is not null or undefined
            assertParamExists('changeTeamMemberRole', 'changeTeamMemberRoleRequest', changeTeamMemberRoleRequest)
            const localVarPath = `/api/v1/teams/{team_id}/members/{user_id}/role`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeTeamMemberRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a team exists by name
         * @param {string} teamName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTeamExists: async (teamName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamName' is not null or undefined
            assertParamExists('checkTeamExists', 'teamName', teamName)
            const localVarPath = `/api/v1/teams/check-exists/{team_name}`
                .replace(`{${"team_name"}}`, encodeURIComponent(String(teamName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compare two releases analytics
         * @param {number} projectId 
         * @param {CompareProjectReleasesAnalyticsRequest} compareProjectReleasesAnalyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareProjectReleasesAnalytics: async (projectId: number, compareProjectReleasesAnalyticsRequest: CompareProjectReleasesAnalyticsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('compareProjectReleasesAnalytics', 'projectId', projectId)
            // verify required parameter 'compareProjectReleasesAnalyticsRequest' is not null or undefined
            assertParamExists('compareProjectReleasesAnalytics', 'compareProjectReleasesAnalyticsRequest', compareProjectReleasesAnalyticsRequest)
            const localVarPath = `/api/v1/projects/{project_id}/analytics/releases/compare`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compareProjectReleasesAnalyticsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm2FA: async (twoFAConfirmRequest: TwoFAConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAConfirmRequest' is not null or undefined
            assertParamExists('confirm2FA', 'twoFAConfirmRequest', twoFAConfirmRequest)
            const localVarPath = `/api/v1/users/me/2fa/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {CreateNotificationRuleRequest} createNotificationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationRule: async (projectId: number, settingId: number, createNotificationRuleRequest: CreateNotificationRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createNotificationRule', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('createNotificationRule', 'settingId', settingId)
            // verify required parameter 'createNotificationRuleRequest' is not null or undefined
            assertParamExists('createNotificationRule', 'createNotificationRuleRequest', createNotificationRuleRequest)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}/rules`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new notification setting
         * @param {number} projectId 
         * @param {CreateNotificationSettingRequest} createNotificationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSetting: async (projectId: number, createNotificationSettingRequest: CreateNotificationSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createNotificationSetting', 'projectId', projectId)
            // verify required parameter 'createNotificationSettingRequest' is not null or undefined
            assertParamExists('createNotificationSetting', 'createNotificationSettingRequest', createNotificationSettingRequest)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new team
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamRequest: CreateTeamRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamRequest' is not null or undefined
            assertParamExists('createTeam', 'createTeamRequest', createTeamRequest)
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationRule: async (projectId: number, settingId: number, ruleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteNotificationRule', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('deleteNotificationRule', 'settingId', settingId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('deleteNotificationRule', 'ruleId', ruleId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}/rules/{rule_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSetting: async (projectId: number, settingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteNotificationSetting', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('deleteNotificationSetting', 'settingId', settingId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a team
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA: async (twoFADisableRequest: TwoFADisableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFADisableRequest' is not null or undefined
            assertParamExists('disable2FA', 'twoFADisableRequest', twoFADisableRequest)
            const localVarPath = `/api/v1/users/me/2fa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFADisableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordRequest: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordRequest', forgotPasswordRequest)
            const localVarPath = `/api/v1/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events timeseries
         * @param {string} interval 
         * @param {string} granularity 
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsTimeseries: async (interval: string, granularity: string, projectId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getEventsTimeseries', 'interval', interval)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('getEventsTimeseries', 'granularity', granularity)
            const localVarPath = `/api/v1/events/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a specific issue
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssue: async (projectId: number, issueId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getIssue', 'projectId', projectId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('getIssue', 'issueId', issueId)
            const localVarPath = `/api/v1/projects/{project_id}/issues/{issue_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get issues timeseries
         * @param {string} interval 
         * @param {string} granularity 
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssuesTimeseries: async (interval: string, granularity: string, projectId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getIssuesTimeseries', 'interval', interval)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('getIssuesTimeseries', 'granularity', granularity)
            const localVarPath = `/api/v1/issues/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationRule: async (projectId: number, settingId: number, ruleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationRule', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('getNotificationRule', 'settingId', settingId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('getNotificationRule', 'ruleId', ruleId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}/rules/{rule_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSetting: async (projectId: number, settingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationSetting', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('getNotificationSetting', 'settingId', settingId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project details
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get timeseries of events for a specific issue inside a project
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIssueEventsTimeseries: async (projectId: number, issueId: number, interval: string, granularity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectIssueEventsTimeseries', 'projectId', projectId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('getProjectIssueEventsTimeseries', 'issueId', issueId)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getProjectIssueEventsTimeseries', 'interval', interval)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('getProjectIssueEventsTimeseries', 'granularity', granularity)
            const localVarPath = `/api/v1/projects/{project_id}/issues/{issue_id}/events/timeseries`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get timeseries for a specific issue inside a project
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIssueTimeseries: async (projectId: number, issueId: number, interval: string, granularity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectIssueTimeseries', 'projectId', projectId)
            // verify required parameter 'issueId' is not null or undefined
            assertParamExists('getProjectIssueTimeseries', 'issueId', issueId)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getProjectIssueTimeseries', 'interval', interval)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('getProjectIssueTimeseries', 'granularity', granularity)
            const localVarPath = `/api/v1/projects/{project_id}/issues/{issue_id}/timeseries`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get analytics details for a specific release
         * @param {number} projectId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseAnalyticsDetails: async (projectId: number, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectReleaseAnalyticsDetails', 'projectId', projectId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getProjectReleaseAnalyticsDetails', 'version', version)
            const localVarPath = `/api/v1/projects/{project_id}/analytics/releases/{version}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get errors timeseries for a release
         * @param {number} projectId 
         * @param {string} release 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {IssueLevel} [level] 
         * @param {GetProjectReleaseErrorsTimeseriesGroupByEnum} [groupBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseErrorsTimeseries: async (projectId: number, release: string, interval: string, granularity: string, level?: IssueLevel, groupBy?: GetProjectReleaseErrorsTimeseriesGroupByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectReleaseErrorsTimeseries', 'projectId', projectId)
            // verify required parameter 'release' is not null or undefined
            assertParamExists('getProjectReleaseErrorsTimeseries', 'release', release)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getProjectReleaseErrorsTimeseries', 'interval', interval)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('getProjectReleaseErrorsTimeseries', 'granularity', granularity)
            const localVarPath = `/api/v1/projects/{project_id}/analytics/traffic`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user segments analytics for a release
         * @param {number} projectId 
         * @param {string} release 
         * @param {GetProjectReleaseSegmentsSegmentEnum} segment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseSegments: async (projectId: number, release: string, segment: GetProjectReleaseSegmentsSegmentEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectReleaseSegments', 'projectId', projectId)
            // verify required parameter 'release' is not null or undefined
            assertParamExists('getProjectReleaseSegments', 'release', release)
            // verify required parameter 'segment' is not null or undefined
            assertParamExists('getProjectReleaseSegments', 'segment', segment)
            const localVarPath = `/api/v1/projects/{project_id}/analytics/segments`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (segment !== undefined) {
                localVarQueryParameter['segment'] = segment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get analytics summary for all releases in project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleasesAnalytics: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectReleasesAnalytics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/analytics/releases`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project statistics
         * @param {number} projectId 
         * @param {GetProjectStatsPeriodEnum} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectStats: async (projectId: number, period: GetProjectStatsPeriodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectStats', 'projectId', projectId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getProjectStats', 'period', period)
            const localVarPath = `/api/v1/projects/{project_id}/stats`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project team
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTeam: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectTeam', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/team`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent issues across all projects
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentIssues: async (limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getRecentIssues', 'limit', limit)
            const localVarPath = `/api/v1/issues/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get team details
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get unread notifications count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotificationsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/unread-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user notifications
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns versions and build times of all Warden system components by collecting data from their tech servers
         * @summary Get versions of all system components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all issues across all projects
         * @param {number} perPage 
         * @param {number} page 
         * @param {IssueLevel} [level] 
         * @param {IssueStatus} [status] 
         * @param {number} [projectId] 
         * @param {IssueSortColumn} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIssues: async (perPage: number, page: number, level?: IssueLevel, status?: IssueStatus, projectId?: number, sortBy?: IssueSortColumn, sortOrder?: SortOrder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('listIssues', 'perPage', perPage)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('listIssues', 'page', page)
            const localVarPath = `/api/v1/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all notification rules for notification settings of project
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationRules: async (projectId: number, settingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listNotificationRules', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('listNotificationRules', 'settingId', settingId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}/rules`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all notification settings for a project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationSettings: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listNotificationSettings', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users for team admin
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersForTeam: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listUsersForTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/users/team/{team_id}/list`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark all notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllNotificationsAsRead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/read-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead: async (notificationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('markNotificationAsRead', 'notificationId', notificationId)
            const localVarPath = `/api/v1/notifications/{notification_id}/read`
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentProjectsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a user from a team. If user_id matches the current user\'s id, the operation is treated as self-leave (the user leaves the team).  Scenarios: - Admin/owner removes another user - User removes themselves (leave)  Restrictions: - A user cannot leave the team if they are the only owner - A superuser cannot leave the team if restricted by security policy 
         * @summary Remove a user from a team (or self-leave)
         * @param {number} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamMember: async (teamId: number, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeTeamMember', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeTeamMember', 'userId', userId)
            const localVarPath = `/api/v1/teams/{team_id}/members/{user_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset2FA: async (twoFAResetRequest: TwoFAResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAResetRequest' is not null or undefined
            assertParamExists('reset2FA', 'twoFAResetRequest', twoFAResetRequest)
            const localVarPath = `/api/v1/users/me/2fa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send test notification
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotification: async (projectId: number, settingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('sendTestNotification', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('sendTestNotification', 'settingId', settingId)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}/test`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSuperuserStatus: async (userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setSuperuserStatus', 'userId', userId)
            // verify required parameter 'setSuperuserStatusRequest' is not null or undefined
            assertParamExists('setSuperuserStatus', 'setSuperuserStatusRequest', setSuperuserStatusRequest)
            const localVarPath = `/api/v1/users/{user_id}/superuser`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSuperuserStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserActiveStatus: async (userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserActiveStatus', 'userId', userId)
            // verify required parameter 'setUserActiveStatusRequest' is not null or undefined
            assertParamExists('setUserActiveStatus', 'setUserActiveStatusRequest', setUserActiveStatusRequest)
            const localVarPath = `/api/v1/users/{user_id}/active`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserActiveStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup2FA: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/2fa/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {UpdateNotificationRuleRequest} updateNotificationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationRule: async (projectId: number, settingId: number, ruleId: number, updateNotificationRuleRequest: UpdateNotificationRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateNotificationRule', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('updateNotificationRule', 'settingId', settingId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('updateNotificationRule', 'ruleId', ruleId)
            // verify required parameter 'updateNotificationRuleRequest' is not null or undefined
            assertParamExists('updateNotificationRule', 'updateNotificationRuleRequest', updateNotificationRuleRequest)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}/rules/{rule_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {UpdateNotificationSettingRequest} updateNotificationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSetting: async (projectId: number, settingId: number, updateNotificationSettingRequest: UpdateNotificationSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateNotificationSetting', 'projectId', projectId)
            // verify required parameter 'settingId' is not null or undefined
            assertParamExists('updateNotificationSetting', 'settingId', settingId)
            // verify required parameter 'updateNotificationSettingRequest' is not null or undefined
            assertParamExists('updateNotificationSetting', 'updateNotificationSettingRequest', updateNotificationSettingRequest)
            const localVarPath = `/api/v1/projects/{project_id}/notification-settings/{setting_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"setting_id"}}`, encodeURIComponent(String(settingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project name and description
         * @param {number} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: number, updateProjectRequest: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            // verify required parameter 'updateProjectRequest' is not null or undefined
            assertParamExists('updateProject', 'updateProjectRequest', updateProjectRequest)
            const localVarPath = `/api/v1/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeMyPassword: async (changeUserPasswordRequest: ChangeUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeUserPasswordRequest' is not null or undefined
            assertParamExists('userChangeMyPassword', 'changeUserPasswordRequest', changeUserPasswordRequest)
            const localVarPath = `/api/v1/users/me/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: async (twoFAVerifyRequest: TwoFAVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFAVerifyRequest' is not null or undefined
            assertParamExists('verify2FA', 'twoFAVerifyRequest', twoFAVerifyRequest)
            const localVarPath = `/api/v1/auth/2fa/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFAVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProject(addProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a user to a team
         * @param {number} teamId 
         * @param {AddTeamMemberRequest} addTeamMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeamMember(teamId: number, addTeamMemberRequest: AddTeamMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamMember(teamId, addTeamMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Archive a project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.archiveProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change issue status
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {ChangeIssueStatusRequest} changeIssueStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeIssueStatus(projectId: number, issueId: number, changeIssueStatusRequest: ChangeIssueStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeIssueStatus(projectId, issueId, changeIssueStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changeIssueStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change team member role
         * @param {number} teamId 
         * @param {number} userId 
         * @param {ChangeTeamMemberRoleRequest} changeTeamMemberRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTeamMemberRole(teamId: number, userId: number, changeTeamMemberRoleRequest: ChangeTeamMemberRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTeamMemberRole(teamId, userId, changeTeamMemberRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changeTeamMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if a team exists by name
         * @param {string} teamName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTeamExists(teamName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamExistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTeamExists(teamName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.checkTeamExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Compare two releases analytics
         * @param {number} projectId 
         * @param {CompareProjectReleasesAnalyticsRequest} compareProjectReleasesAnalyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compareProjectReleasesAnalytics(projectId: number, compareProjectReleasesAnalyticsRequest: CompareProjectReleasesAnalyticsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseComparison>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareProjectReleasesAnalytics(projectId, compareProjectReleasesAnalyticsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.compareProjectReleasesAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm2FA(twoFAConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.confirm2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {CreateNotificationRuleRequest} createNotificationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationRule(projectId: number, settingId: number, createNotificationRuleRequest: CreateNotificationRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationRule(projectId, settingId, createNotificationRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createNotificationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new notification setting
         * @param {number} projectId 
         * @param {CreateNotificationSettingRequest} createNotificationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationSetting(projectId: number, createNotificationSettingRequest: CreateNotificationSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationSetting(projectId, createNotificationSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createNotificationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new team
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamRequest: CreateTeamRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationRule(projectId: number, settingId: number, ruleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationRule(projectId, settingId, ruleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteNotificationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationSetting(projectId: number, settingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationSetting(projectId, settingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteNotificationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a team
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disable2FA(twoFADisableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.disable2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get events timeseries
         * @param {string} interval 
         * @param {string} granularity 
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsTimeseries(interval: string, granularity: string, projectId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeseriesData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsTimeseries(interval, granularity, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEventsTimeseries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a specific issue
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIssue(projectId: number, issueId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIssue(projectId, issueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get issues timeseries
         * @param {string} interval 
         * @param {string} granularity 
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIssuesTimeseries(interval: string, granularity: string, projectId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeseriesData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIssuesTimeseries(interval, granularity, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIssuesTimeseries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationRule(projectId: number, settingId: number, ruleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationRule(projectId, settingId, ruleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNotificationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSetting(projectId: number, settingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSetting(projectId, settingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNotificationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project details
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get timeseries of events for a specific issue inside a project
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectIssueEventsTimeseries(projectId: number, issueId: number, interval: string, granularity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeseriesData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectIssueEventsTimeseries(projectId, issueId, interval, granularity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectIssueEventsTimeseries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get timeseries for a specific issue inside a project
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectIssueTimeseries(projectId: number, issueId: number, interval: string, granularity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeseriesData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectIssueTimeseries(projectId, issueId, interval, granularity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectIssueTimeseries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get analytics details for a specific release
         * @param {number} projectId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectReleaseAnalyticsDetails(projectId: number, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseAnalyticsDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectReleaseAnalyticsDetails(projectId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectReleaseAnalyticsDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get errors timeseries for a release
         * @param {number} projectId 
         * @param {string} release 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {IssueLevel} [level] 
         * @param {GetProjectReleaseErrorsTimeseriesGroupByEnum} [groupBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectReleaseErrorsTimeseries(projectId: number, release: string, interval: string, granularity: string, level?: IssueLevel, groupBy?: GetProjectReleaseErrorsTimeseriesGroupByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeseriesData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectReleaseErrorsTimeseries(projectId, release, interval, granularity, level, groupBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectReleaseErrorsTimeseries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user segments analytics for a release
         * @param {number} projectId 
         * @param {string} release 
         * @param {GetProjectReleaseSegmentsSegmentEnum} segment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectReleaseSegments(projectId: number, release: string, segment: GetProjectReleaseSegmentsSegmentEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseSegmentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectReleaseSegments(projectId, release, segment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectReleaseSegments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get analytics summary for all releases in project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectReleasesAnalytics(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReleaseAnalyticsSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectReleasesAnalytics(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectReleasesAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project statistics
         * @param {number} projectId 
         * @param {GetProjectStatsPeriodEnum} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectStats(projectId: number, period: GetProjectStatsPeriodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectStats(projectId, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project team
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectTeam(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectTeam(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recent issues across all projects
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentIssues(limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListIssueSummariesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentIssues(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRecentIssues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get team details
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeam(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get unread notifications count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnreadNotificationsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnreadCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnreadNotificationsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUnreadNotificationsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user notifications
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNotificationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUserNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns versions and build times of all Warden system components by collecting data from their tech servers
         * @summary Get versions of all system components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all issues across all projects
         * @param {number} perPage 
         * @param {number} page 
         * @param {IssueLevel} [level] 
         * @param {IssueStatus} [status] 
         * @param {number} [projectId] 
         * @param {IssueSortColumn} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIssues(perPage: number, page: number, level?: IssueLevel, status?: IssueStatus, projectId?: number, sortBy?: IssueSortColumn, sortOrder?: SortOrder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListIssuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIssues(perPage, page, level, status, projectId, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIssues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all notification rules for notification settings of project
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotificationRules(projectId: number, settingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNotificationRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotificationRules(projectId, settingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listNotificationRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all notification settings for a project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotificationSettings(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNotificationSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotificationSettings(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listNotificationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeams(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeams(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all users for team admin
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersForTeam(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersForTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listUsersForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark all notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAllNotificationsAsRead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAllNotificationsAsRead(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.markAllNotificationsAsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markNotificationAsRead(notificationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markNotificationAsRead(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.markNotificationAsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recent projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentProjectsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentProjectsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recentProjectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a user from a team. If user_id matches the current user\'s id, the operation is treated as self-leave (the user leaves the team).  Scenarios: - Admin/owner removes another user - User removes themselves (leave)  Restrictions: - A user cannot leave the team if they are the only owner - A superuser cannot leave the team if restricted by security policy 
         * @summary Remove a user from a team (or self-leave)
         * @param {number} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamMember(teamId: number, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamMember(teamId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.removeTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFASetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reset2FA(twoFAResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.reset2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send test notification
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestNotification(projectId: number, settingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestNotification(projectId, settingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sendTestNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSuperuserStatus(userId, setSuperuserStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setSuperuserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserActiveStatus(userId, setUserActiveStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setUserActiveStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup2FA(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFASetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup2FA(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setup2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {UpdateNotificationRuleRequest} updateNotificationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationRule(projectId: number, settingId: number, ruleId: number, updateNotificationRuleRequest: UpdateNotificationRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationRule(projectId, settingId, ruleId, updateNotificationRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateNotificationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {UpdateNotificationSettingRequest} updateNotificationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationSetting(projectId: number, settingId: number, updateNotificationSettingRequest: UpdateNotificationSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationSetting(projectId, settingId, updateNotificationSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateNotificationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project name and description
         * @param {number} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: number, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userChangeMyPassword(changeUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userChangeMyPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFAVerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify2FA(twoFAVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verify2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {AddProjectRequest} addProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addProject(addProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a user to a team
         * @param {number} teamId 
         * @param {AddTeamMemberRequest} addTeamMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamMember(teamId: number, addTeamMemberRequest: AddTeamMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addTeamMember(teamId, addTeamMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive a project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change issue status
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {ChangeIssueStatusRequest} changeIssueStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeIssueStatus(projectId: number, issueId: number, changeIssueStatusRequest: ChangeIssueStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeIssueStatus(projectId, issueId, changeIssueStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change team member role
         * @param {number} teamId 
         * @param {number} userId 
         * @param {ChangeTeamMemberRoleRequest} changeTeamMemberRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamMemberRole(teamId: number, userId: number, changeTeamMemberRoleRequest: ChangeTeamMemberRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeTeamMemberRole(teamId, userId, changeTeamMemberRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a team exists by name
         * @param {string} teamName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTeamExists(teamName: string, options?: RawAxiosRequestConfig): AxiosPromise<TeamExistsResponse> {
            return localVarFp.checkTeamExists(teamName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compare two releases analytics
         * @param {number} projectId 
         * @param {CompareProjectReleasesAnalyticsRequest} compareProjectReleasesAnalyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareProjectReleasesAnalytics(projectId: number, compareProjectReleasesAnalyticsRequest: CompareProjectReleasesAnalyticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseComparison> {
            return localVarFp.compareProjectReleasesAnalytics(projectId, compareProjectReleasesAnalyticsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve enable 2FA (code from app)
         * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirm2FA(twoFAConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {CreateNotificationRuleRequest} createNotificationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationRule(projectId: number, settingId: number, createNotificationRuleRequest: CreateNotificationRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationRule> {
            return localVarFp.createNotificationRule(projectId, settingId, createNotificationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new notification setting
         * @param {number} projectId 
         * @param {CreateNotificationSettingRequest} createNotificationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSetting(projectId: number, createNotificationSettingRequest: CreateNotificationSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationSetting> {
            return localVarFp.createNotificationSetting(projectId, createNotificationSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new team
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamRequest: CreateTeamRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateTeamResponse> {
            return localVarFp.createTeam(createTeamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user (superuser only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserResponse> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationRule(projectId: number, settingId: number, ruleId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNotificationRule(projectId, settingId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSetting(projectId: number, settingId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNotificationSetting(projectId, settingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a team
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user (superuser only, cannot delete superusers)
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable 2FA (using email-confirmation)
         * @param {TwoFADisableRequest} twoFADisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disable2FA(twoFADisableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.forgotPassword(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events timeseries
         * @param {string} interval 
         * @param {string} granularity 
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsTimeseries(interval: string, granularity: string, projectId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeseriesData>> {
            return localVarFp.getEventsTimeseries(interval, granularity, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a specific issue
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssue(projectId: number, issueId: number, options?: RawAxiosRequestConfig): AxiosPromise<IssueResponse> {
            return localVarFp.getIssue(projectId, issueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get issues timeseries
         * @param {string} interval 
         * @param {string} granularity 
         * @param {number} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssuesTimeseries(interval: string, granularity: string, projectId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeseriesData>> {
            return localVarFp.getIssuesTimeseries(interval, granularity, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationRule(projectId: number, settingId: number, ruleId: number, options?: RawAxiosRequestConfig): AxiosPromise<NotificationRule> {
            return localVarFp.getNotificationRule(projectId, settingId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSetting(projectId: number, settingId: number, options?: RawAxiosRequestConfig): AxiosPromise<NotificationSetting> {
            return localVarFp.getNotificationSetting(projectId, settingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project details
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get timeseries of events for a specific issue inside a project
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIssueEventsTimeseries(projectId: number, issueId: number, interval: string, granularity: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeseriesData>> {
            return localVarFp.getProjectIssueEventsTimeseries(projectId, issueId, interval, granularity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get timeseries for a specific issue inside a project
         * @param {number} projectId 
         * @param {number} issueId 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIssueTimeseries(projectId: number, issueId: number, interval: string, granularity: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeseriesData>> {
            return localVarFp.getProjectIssueTimeseries(projectId, issueId, interval, granularity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get analytics details for a specific release
         * @param {number} projectId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseAnalyticsDetails(projectId: number, version: string, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseAnalyticsDetails> {
            return localVarFp.getProjectReleaseAnalyticsDetails(projectId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get errors timeseries for a release
         * @param {number} projectId 
         * @param {string} release 
         * @param {string} interval 
         * @param {string} granularity 
         * @param {IssueLevel} [level] 
         * @param {GetProjectReleaseErrorsTimeseriesGroupByEnum} [groupBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseErrorsTimeseries(projectId: number, release: string, interval: string, granularity: string, level?: IssueLevel, groupBy?: GetProjectReleaseErrorsTimeseriesGroupByEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeseriesData>> {
            return localVarFp.getProjectReleaseErrorsTimeseries(projectId, release, interval, granularity, level, groupBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user segments analytics for a release
         * @param {number} projectId 
         * @param {string} release 
         * @param {GetProjectReleaseSegmentsSegmentEnum} segment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseSegments(projectId: number, release: string, segment: GetProjectReleaseSegmentsSegmentEnum, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseSegmentsResponse> {
            return localVarFp.getProjectReleaseSegments(projectId, release, segment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get analytics summary for all releases in project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleasesAnalytics(projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReleaseAnalyticsSummary>> {
            return localVarFp.getProjectReleasesAnalytics(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project statistics
         * @param {number} projectId 
         * @param {GetProjectStatsPeriodEnum} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectStats(projectId: number, period: GetProjectStatsPeriodEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProjectStatsResponse> {
            return localVarFp.getProjectStats(projectId, period, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project team
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTeam(projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<TeamResponse> {
            return localVarFp.getProjectTeam(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recent issues across all projects
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentIssues(limit: number, options?: RawAxiosRequestConfig): AxiosPromise<ListIssueSummariesResponse> {
            return localVarFp.getRecentIssues(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get team details
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<Team> {
            return localVarFp.getTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get unread notifications count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotificationsCount(options?: RawAxiosRequestConfig): AxiosPromise<UnreadCountResponse> {
            return localVarFp.getUnreadNotificationsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user notifications
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserNotificationsResponse> {
            return localVarFp.getUserNotifications(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns versions and build times of all Warden system components by collecting data from their tech servers
         * @summary Get versions of all system components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: RawAxiosRequestConfig): AxiosPromise<VersionsResponse> {
            return localVarFp.getVersions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all issues across all projects
         * @param {number} perPage 
         * @param {number} page 
         * @param {IssueLevel} [level] 
         * @param {IssueStatus} [status] 
         * @param {number} [projectId] 
         * @param {IssueSortColumn} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIssues(perPage: number, page: number, level?: IssueLevel, status?: IssueStatus, projectId?: number, sortBy?: IssueSortColumn, sortOrder?: SortOrder, options?: RawAxiosRequestConfig): AxiosPromise<ListIssuesResponse> {
            return localVarFp.listIssues(perPage, page, level, status, projectId, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all notification rules for notification settings of project
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationRules(projectId: number, settingId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListNotificationRulesResponse> {
            return localVarFp.listNotificationRules(projectId, settingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all notification settings for a project
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotificationSettings(projectId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListNotificationSettingsResponse> {
            return localVarFp.listNotificationSettings(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(options?: RawAxiosRequestConfig): AxiosPromise<Array<Team>> {
            return localVarFp.listTeams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users (superuser only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users for team admin
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersForTeam(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsersForTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate user and get access token
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark all notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllNotificationsAsRead(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markAllNotificationsAsRead(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead(notificationId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markNotificationAsRead(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recent projects list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentProjectsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.recentProjectsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshToken(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a user from a team. If user_id matches the current user\'s id, the operation is treated as self-leave (the user leaves the team).  Scenarios: - Admin/owner removes another user - User removes themselves (leave)  Restrictions: - A user cannot leave the team if they are the only owner - A superuser cannot leave the team if restricted by security policy 
         * @summary Remove a user from a team (or self-leave)
         * @param {number} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamMember(teamId: number, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTeamMember(teamId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset/generate secret 2FA (using email-confirmation)
         * @param {TwoFAResetRequest} twoFAResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFASetupResponse> {
            return localVarFp.reset2FA(twoFAResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password using token
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send test notification
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotification(projectId: number, settingId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendTestNotification(projectId, settingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset superuser status (superuser only, cannot modify admin user)
         * @param {number} userId 
         * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.setSuperuserStatus(userId, setSuperuserStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set or unset user active status (superuser only)
         * @param {number} userId 
         * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.setUserActiveStatus(userId, setUserActiveStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Begin setup 2FA (generate secret and QR-code)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup2FA(options?: RawAxiosRequestConfig): AxiosPromise<TwoFASetupResponse> {
            return localVarFp.setup2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a notification rule
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {number} ruleId 
         * @param {UpdateNotificationRuleRequest} updateNotificationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationRule(projectId: number, settingId: number, ruleId: number, updateNotificationRuleRequest: UpdateNotificationRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationRule> {
            return localVarFp.updateNotificationRule(projectId, settingId, ruleId, updateNotificationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a notification setting
         * @param {number} projectId 
         * @param {number} settingId 
         * @param {UpdateNotificationSettingRequest} updateNotificationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSetting(projectId: number, settingId: number, updateNotificationSettingRequest: UpdateNotificationSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationSetting> {
            return localVarFp.updateNotificationSetting(projectId, settingId, updateNotificationSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project name and description
         * @param {number} projectId 
         * @param {UpdateProjectRequest} updateProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: number, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponse> {
            return localVarFp.updateProject(projectId, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change my password
         * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userChangeMyPassword(changeUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify 2FA-code on login
         * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFAVerifyResponse> {
            return localVarFp.verify2FA(twoFAVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add new project
     * @param {AddProjectRequest} addProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addProject(addProjectRequest: AddProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addProject(addProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a user to a team
     * @param {number} teamId 
     * @param {AddTeamMemberRequest} addTeamMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addTeamMember(teamId: number, addTeamMemberRequest: AddTeamMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addTeamMember(teamId, addTeamMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive a project
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public archiveProject(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).archiveProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change issue status
     * @param {number} projectId 
     * @param {number} issueId 
     * @param {ChangeIssueStatusRequest} changeIssueStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changeIssueStatus(projectId: number, issueId: number, changeIssueStatusRequest: ChangeIssueStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changeIssueStatus(projectId, issueId, changeIssueStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change team member role
     * @param {number} teamId 
     * @param {number} userId 
     * @param {ChangeTeamMemberRoleRequest} changeTeamMemberRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changeTeamMemberRole(teamId: number, userId: number, changeTeamMemberRoleRequest: ChangeTeamMemberRoleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changeTeamMemberRole(teamId, userId, changeTeamMemberRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a team exists by name
     * @param {string} teamName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkTeamExists(teamName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkTeamExists(teamName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compare two releases analytics
     * @param {number} projectId 
     * @param {CompareProjectReleasesAnalyticsRequest} compareProjectReleasesAnalyticsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public compareProjectReleasesAnalytics(projectId: number, compareProjectReleasesAnalyticsRequest: CompareProjectReleasesAnalyticsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).compareProjectReleasesAnalytics(projectId, compareProjectReleasesAnalyticsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve enable 2FA (code from app)
     * @param {TwoFAConfirmRequest} twoFAConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public confirm2FA(twoFAConfirmRequest: TwoFAConfirmRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).confirm2FA(twoFAConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new notification rule
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {CreateNotificationRuleRequest} createNotificationRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createNotificationRule(projectId: number, settingId: number, createNotificationRuleRequest: CreateNotificationRuleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createNotificationRule(projectId, settingId, createNotificationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new notification setting
     * @param {number} projectId 
     * @param {CreateNotificationSettingRequest} createNotificationSettingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createNotificationSetting(projectId: number, createNotificationSettingRequest: CreateNotificationSettingRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createNotificationSetting(projectId, createNotificationSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new team
     * @param {CreateTeamRequest} createTeamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTeam(createTeamRequest: CreateTeamRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTeam(createTeamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user (superuser only)
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a notification rule
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {number} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteNotificationRule(projectId: number, settingId: number, ruleId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteNotificationRule(projectId, settingId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a notification setting
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteNotificationSetting(projectId: number, settingId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteNotificationSetting(projectId, settingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a team
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteTeam(teamId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user (superuser only, cannot delete superusers)
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUser(userId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable 2FA (using email-confirmation)
     * @param {TwoFADisableRequest} twoFADisableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public disable2FA(twoFADisableRequest: TwoFADisableRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).disable2FA(twoFADisableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a password reset
     * @param {ForgotPasswordRequest} forgotPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forgotPassword(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events timeseries
     * @param {string} interval 
     * @param {string} granularity 
     * @param {number} [projectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEventsTimeseries(interval: string, granularity: string, projectId?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEventsTimeseries(interval, granularity, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a specific issue
     * @param {number} projectId 
     * @param {number} issueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIssue(projectId: number, issueId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIssue(projectId, issueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get issues timeseries
     * @param {string} interval 
     * @param {string} granularity 
     * @param {number} [projectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIssuesTimeseries(interval: string, granularity: string, projectId?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIssuesTimeseries(interval, granularity, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific notification rule
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {number} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNotificationRule(projectId: number, settingId: number, ruleId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNotificationRule(projectId, settingId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific notification setting
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNotificationSetting(projectId: number, settingId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNotificationSetting(projectId, settingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project details
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProject(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get timeseries of events for a specific issue inside a project
     * @param {number} projectId 
     * @param {number} issueId 
     * @param {string} interval 
     * @param {string} granularity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectIssueEventsTimeseries(projectId: number, issueId: number, interval: string, granularity: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectIssueEventsTimeseries(projectId, issueId, interval, granularity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get timeseries for a specific issue inside a project
     * @param {number} projectId 
     * @param {number} issueId 
     * @param {string} interval 
     * @param {string} granularity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectIssueTimeseries(projectId: number, issueId: number, interval: string, granularity: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectIssueTimeseries(projectId, issueId, interval, granularity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get analytics details for a specific release
     * @param {number} projectId 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectReleaseAnalyticsDetails(projectId: number, version: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectReleaseAnalyticsDetails(projectId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get errors timeseries for a release
     * @param {number} projectId 
     * @param {string} release 
     * @param {string} interval 
     * @param {string} granularity 
     * @param {IssueLevel} [level] 
     * @param {GetProjectReleaseErrorsTimeseriesGroupByEnum} [groupBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectReleaseErrorsTimeseries(projectId: number, release: string, interval: string, granularity: string, level?: IssueLevel, groupBy?: GetProjectReleaseErrorsTimeseriesGroupByEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectReleaseErrorsTimeseries(projectId, release, interval, granularity, level, groupBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user segments analytics for a release
     * @param {number} projectId 
     * @param {string} release 
     * @param {GetProjectReleaseSegmentsSegmentEnum} segment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectReleaseSegments(projectId: number, release: string, segment: GetProjectReleaseSegmentsSegmentEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectReleaseSegments(projectId, release, segment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get analytics summary for all releases in project
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectReleasesAnalytics(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectReleasesAnalytics(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project statistics
     * @param {number} projectId 
     * @param {GetProjectStatsPeriodEnum} period 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectStats(projectId: number, period: GetProjectStatsPeriodEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectStats(projectId, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project team
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectTeam(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectTeam(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recent issues across all projects
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentIssues(limit: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentIssues(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get team details
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTeam(teamId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get unread notifications count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUnreadNotificationsCount(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUnreadNotificationsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user notifications
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserNotifications(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserNotifications(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns versions and build times of all Warden system components by collecting data from their tech servers
     * @summary Get versions of all system components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVersions(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVersions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all issues across all projects
     * @param {number} perPage 
     * @param {number} page 
     * @param {IssueLevel} [level] 
     * @param {IssueStatus} [status] 
     * @param {number} [projectId] 
     * @param {IssueSortColumn} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIssues(perPage: number, page: number, level?: IssueLevel, status?: IssueStatus, projectId?: number, sortBy?: IssueSortColumn, sortOrder?: SortOrder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIssues(perPage, page, level, status, projectId, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all notification rules for notification settings of project
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNotificationRules(projectId: number, settingId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listNotificationRules(projectId, settingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all notification settings for a project
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNotificationSettings(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listNotificationSettings(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projects list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTeams(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTeams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users (superuser only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users for team admin
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listUsersForTeam(teamId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listUsersForTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate user and get access token
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark all notifications as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public markAllNotificationsAsRead(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).markAllNotificationsAsRead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark notification as read
     * @param {number} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public markNotificationAsRead(notificationId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).markNotificationAsRead(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recent projects list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public recentProjectsList(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recentProjectsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshToken(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a user from a team. If user_id matches the current user\'s id, the operation is treated as self-leave (the user leaves the team).  Scenarios: - Admin/owner removes another user - User removes themselves (leave)  Restrictions: - A user cannot leave the team if they are the only owner - A superuser cannot leave the team if restricted by security policy 
     * @summary Remove a user from a team (or self-leave)
     * @param {number} teamId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeTeamMember(teamId: number, userId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeTeamMember(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset/generate secret 2FA (using email-confirmation)
     * @param {TwoFAResetRequest} twoFAResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reset2FA(twoFAResetRequest: TwoFAResetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reset2FA(twoFAResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password using token
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send test notification
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendTestNotification(projectId: number, settingId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendTestNotification(projectId, settingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset superuser status (superuser only, cannot modify admin user)
     * @param {number} userId 
     * @param {SetSuperuserStatusRequest} setSuperuserStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setSuperuserStatus(userId: number, setSuperuserStatusRequest: SetSuperuserStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setSuperuserStatus(userId, setSuperuserStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set or unset user active status (superuser only)
     * @param {number} userId 
     * @param {SetUserActiveStatusRequest} setUserActiveStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setUserActiveStatus(userId: number, setUserActiveStatusRequest: SetUserActiveStatusRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUserActiveStatus(userId, setUserActiveStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Begin setup 2FA (generate secret and QR-code)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setup2FA(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setup2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a notification rule
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {number} ruleId 
     * @param {UpdateNotificationRuleRequest} updateNotificationRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateNotificationRule(projectId: number, settingId: number, ruleId: number, updateNotificationRuleRequest: UpdateNotificationRuleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateNotificationRule(projectId, settingId, ruleId, updateNotificationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a notification setting
     * @param {number} projectId 
     * @param {number} settingId 
     * @param {UpdateNotificationSettingRequest} updateNotificationSettingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateNotificationSetting(projectId: number, settingId: number, updateNotificationSettingRequest: UpdateNotificationSettingRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateNotificationSetting(projectId, settingId, updateNotificationSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project name and description
     * @param {number} projectId 
     * @param {UpdateProjectRequest} updateProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProject(projectId: number, updateProjectRequest: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProject(projectId, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change my password
     * @param {ChangeUserPasswordRequest} changeUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userChangeMyPassword(changeUserPasswordRequest: ChangeUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userChangeMyPassword(changeUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify 2FA-code on login
     * @param {TwoFAVerifyRequest} twoFAVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verify2FA(twoFAVerifyRequest: TwoFAVerifyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verify2FA(twoFAVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetProjectReleaseErrorsTimeseriesGroupByEnum = {
    None: 'none',
    Level: 'level'
} as const;
export type GetProjectReleaseErrorsTimeseriesGroupByEnum = typeof GetProjectReleaseErrorsTimeseriesGroupByEnum[keyof typeof GetProjectReleaseErrorsTimeseriesGroupByEnum];
/**
 * @export
 */
export const GetProjectReleaseSegmentsSegmentEnum = {
    Platform: 'platform',
    BrowserName: 'browser_name',
    OsName: 'os_name',
    DeviceArch: 'device_arch',
    RuntimeName: 'runtime_name'
} as const;
export type GetProjectReleaseSegmentsSegmentEnum = typeof GetProjectReleaseSegmentsSegmentEnum[keyof typeof GetProjectReleaseSegmentsSegmentEnum];
/**
 * @export
 */
export const GetProjectStatsPeriodEnum = {
    _10m: '10m',
    _30m: '30m',
    _1h: '1h',
    _3h: '3h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _3d: '3d',
    _7d: '7d',
    _14d: '14d',
    _30d: '30d'
} as const;
export type GetProjectStatsPeriodEnum = typeof GetProjectStatsPeriodEnum[keyof typeof GetProjectStatsPeriodEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send2FACode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/2fa/send_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async send2FACode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.send2FACode(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.send2FACode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Send 2FA email code for disable/reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send2FACode(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.send2FACode(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Send 2FA email code for disable/reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public send2FACode(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).send2FACode(options).then((request) => request(this.axios, this.basePath));
    }
}



